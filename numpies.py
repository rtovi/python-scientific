"""
==================
Numpies ðŸŽ‚  Arrays 
==================

Working with tensor arrays on python.  

Python has a built-in structure called list, which is very flexible to perform array operations.
Numpy has extended this structure to work with algebraic tensors by creating 
one of the most powerful packages to perform mathematical processing and numerical operations.

Numpy arrays are the basic processing units in terms of ML/DL.

@NOTE: These tensors are different form the Tensorflow Tensors which are inherently the same structures
 but TensorFlow tensors are adapted to perform parallel and device agnostic processing, which numpy tensors
 do not.

"""
print(__doc__)

# %%

import numpy as np
x = np.array([42,47,11], int)
print (x)
y = np.array( ((11,12,13), (21,22,23), (31,32,33)) )
print (y)

z = np.array( ([11,12,13],[21,22,23],[31,32,33]) )
print (z)


# %%
# Tensors works as algebraic vectors
#Â Array are zero based, array 0 is row, 1 is column.
#Â (r,c)
print ('Element at 0, 1:')
print  (y[0][1])

# Check Array size
print (y.ndim)

# Shape, size, of the array.
print (y.shape)

# Show up to row 2 included (3 excluded)
print (y[:2])

# Show element 1,1, equal to y[1][1]
print (y[1,1])

print ('Shows vertical element 2')
print (y[:,2])

# %%
# Numpy array are "strong" typed
print ('Type of an array:' + str(y.dtype))

# %%
print ('Fundamental: Reshaping arrays....')
f = np.array(range(100))
fr = f.reshape(10,10)
fr[1:-1,1:-1]
print (fr[1:-1,1:-1])

# %%
print ('Array concatenation on the same axis:')
x = np.array([11,22])
y = np.array([18,6])
z = np.array([1,5])
print (x)
print (y)
print (z)
print (np.concatenate((x,y,z)))     # Each x,y,z is dim (2,)

# %%
print ('Array concatenation on the second axis:')
x = np.array([11,22])
y = np.array([18,6])
z = np.array([1,5])
print (x)
print (y)
print (z)                           
print (np.c_[x,y,z])

# %%
print ('Array concatenation of arrays.')
x = np.array(([11,22],[33,22]))
y = np.array(([18,6],[23,22]))
z = np.array(([1,5],[98,76]))
print (x)
print (y)
print (z)
print (np.concatenate((x,y,z)))     # Each x,y,z is dim (2,2)

# %%
print ('Concatenate according to axis')
z = np.concatenate((x,y),axis = 0)
print (z)

# %%
print ('Scaling up tensors.')
x = np.array([2,5,18,14,4])     # Vector of 1 index.
y = x[:, np.newaxis]            # Matriz of two indexes.    
print (x)
print (y)
print(x.ndim)
print(y.ndim)

# %%
# Y has two dimensiones (5,1) while X has only one dimension (5,)
print (y.shape)
print (x.shape)

print (type(y))
print (type(x))

print (y.ndim)
print (x.ndim)

print (y[2,0])                                                                 
print (x[2])    

z = y[:,:, np.newaxis]      # Now z is a tensor (5,1,1)

print (z.ndim)
print (z.shape)

# %%
print("Python Lists =======================")
a=[1,2,3,4,5]

print (a)
print ('List with the last two elements truncated.')
print (a[:-2])

a.append(3)
a.pop(1)
print (a)
print (a.count(1))
a.remove(3)
print (a)
a.extend([3,2])
print (a)
a.reverse()
print (a)
print (a.index(3))
a.sort()
a.insert(2, [3,2])
print (a)


# %%
# Slicing is crucial in multivariate analysis with python

nums = list(range(5))     # range is a built-in function that creates a list of integers
print(nums)               # Prints "[0, 1, 2, 3, 4]"
print(nums[2:4])          # Get a slice from index 2 to 4 (exclusive); prints "[2, 3]"
print(nums[2:])           # Get a slice from index 2 to the end; prints "[2, 3, 4]"
print(nums[:2])           # Get a slice from the start to index 2 (exclusive); prints "[0, 1]"
print(nums[:])            # Get a slice of the whole list; prints "[0, 1, 2, 3, 4]"
print(nums[:-1])          # Slice indices can be negative; prints "[0, 1, 2, 3]"
nums[2:4] = [8, 9]        # Assign a new sublist to a slice
print(nums)               # Prints "[0, 1, 8, 9, 4]"


# %%
# Numpy basic creation and moving around.
import numpy as np

a = np.array([1, 2, 3])   # Create a rank 1 array
print(type(a))            # Prints "<class 'numpy.ndarray'>"
print(a.shape)            # Prints "(3,)"
print(a[0], a[1], a[2])   # Prints "1 2 3"
a[0] = 5                  # Change an element of the array
print(a)                  # Prints "[5, 2, 3]"

b = np.array([[1,2,3],[4,5,6]])    # Create a rank 2 array
print(b.shape)                     # Prints "(2, 3)"
print(b[0, 0], b[0, 1], b[1, 0])   # Prints "1 2 4"



# %%
# Numpy basic creation and moving around.
import numpy as np

a = np.array([1, 2, 3])     # Create a rank 1 array
l = np.delete( 1 )          # Eliminate the element at the position 1
s = a[a==1]                 # Filter the elements from the list that are equal to 1
m = np.where( a==1 )        # Determine the position in a where the matching is true.


# %%
# Numpy Matrix Primitives
import numpy as np

a = np.zeros((2,2))   # Create an array of all zeros
print(a)              # Prints "[[ 0.  0.]
                      #          [ 0.  0.]]"

b = np.ones((1,2))    # Create an array of all ones
print(b)              # Prints "[[ 1.  1.]]"

c = np.full((2,2), 7)  # Create a constant array
print(c)               # Prints "[[ 7.  7.]
                       #          [ 7.  7.]]"

d = np.eye(2)         # Create a 2x2 identity matrix
print(d)              # Prints "[[ 1.  0.]
                      #          [ 0.  1.]]"

e = np.random.random((2,2))  # Create an array filled with random values
print(e)                     # Might print "[[ 0.91940167  0.08143941]
                             #               [ 0.68744134  0.87236687]]"



# %%
# Timeit can be used to mesure processing time
def fn(x):
    return x + x*x + x*x*x

x = np.random.rand(10000,10000).astype(dtype='float32')

%timeit -n5 fn(x)


# %%
# Pulling subarrays from matrixces
import numpy as np

# Create the following rank 2 array with shape (3, 4)
# [[ 1  2  3  4]
#  [ 5  6  7  8]
#  [ 9 10 11 12]]
a = np.array([[1,2,3,4], [5,6,7,8], [9,10,11,12]])

# Use slicing to pull out the subarray consisting of the first 2 rows
# and columns 1 and 2; b is the following array of shape (2, 2):
# [[2 3]
#  [6 7]]
b = a[:2, 1:3]
print(b)

# A slice of an array is a view into the same data, so modifying it
# will modify the original array.
print(a[0, 1])   # Prints "2"
b[0, 0] = 77     # b[0, 0] is the same piece of data as a[0, 1]
print(a[0, 1])   # Prints "77"



# %%
import numpy as np

# Create the following rank 2 array with shape (3, 4) (rank in this context is the number of indices to move around the tensor)
# [[ 1  2  3  4]
#  [ 5  6  7  8]
#  [ 9 10 11 12]]
a = np.array([[1,2,3,4], [5,6,7,8], [9,10,11,12]])

# Two ways of accessing the data in the middle row of the array.
# Mixing integer indexing with slices yields an array of lower rank,
# while using only slices yields an array of the same rank as the
# original array:
row_r1 = a[1, :]    # Rank 1 view of the second row of a
row_r2 = a[1:2, :]  # Rank 2 view of the second row of a
print(row_r1, row_r1.shape)  # Prints "[5 6 7 8] (4,)"
print(row_r2, row_r2.shape)  # Prints "[[5 6 7 8]] (1, 4)"

# We can make the same distinction when accessing columns of an array:
col_r1 = a[:, 1]
col_r2 = a[:, 1:2]
print(col_r1, col_r1.shape)  # Prints "[ 2  6 10] (3,)"
print(col_r2, col_r2.shape)  # Prints "[[ 2]
                             #          [ 6]
                             #          [10]] (3, 1)"


# %%
# Matrix indexing
import numpy as np

a = np.array([[1,2], [3, 4], [5, 6]])

# An example of integer array indexing.
# The returned array will have shape (3,) and
# It selects elements from the 0,1, and 2 row, intersecting 0, 1, 0 column.
print(a[[0, 1, 2], [0, 1, 0]])  # Prints "[1 4 5]", 

# The above example of integer array indexing is equivalent to this:
print(np.array([a[0, 0], a[1, 1], a[2, 0]]))  # Prints "[1 4 5]"

# When using integer array indexing, you can reuse the same
# element from the source array:
print(a[[0, 0], [1, 1]])  # Prints "[2 2]"

# Equivalent to the previous integer array indexing example
print(np.array([a[0, 1], a[0, 1]]))  # Prints "[2 2]"


# %%
# Matrix Indexing
import numpy as np

# Create a new array from which we will select elements
a = np.array([[1,2,3], [4,5,6], [7,8,9], [10, 11, 12]])

print(a)  # prints "array([[ 1,  2,  3],
          #                [ 4,  5,  6],
          #                [ 7,  8,  9],
          #                [10, 11, 12]])"

# Create an array of indices
b = np.array([0, 2, 0, 1])

# Select one element from each row of a using the indices in b
# np.arange(4) is equivalent to np.asarray(list(range(4)))
# This produces [0,1,2,3]  (4 elements ordered starting from zero)
# This is Matrix Indexing: it returns the values for the rows [0,1,2,3] intersecting the column values [0,2,0,1] for the columns
print(a[np.arange(4), b])  # Prints "[ 1  6  7 11]"
print(a[[0,1,2,3],[0,2,0,1]])
print(np.asarray((a[0,0],a[1,2],a[2,0],a[3,1])))   # These all three are equivalent

# Change one element from each row of a using the indices in b
a[np.arange(4), b] += 10

print(a)  # prints "array([[11,  2,  3],
          #                [ 4,  5, 16],
          #                [17,  8,  9],
          #                [10, 21, 12]])


# %%
# Boolean Matrices used for selection
import numpy as np

a = np.array([[1,2], [3, 4], [5, 6]])

bool_idx = (a > 2)   # Find the elements of a that are bigger than 2;
                     # this returns a numpy array of Booleans of the same
                     # shape as a, where each slot of bool_idx tells
                     # whether that element of a is > 2.

print(bool_idx)      # Prints "[[False False]
                     #          [ True  True]
                     #          [ True  True]]"

# We use boolean array indexing to construct a rank 1 array
# consisting of the elements of a corresponding to the True values
# of bool_idx
print(a[bool_idx])  # Prints "[3 4 5 6]"

# We can do all of the above in a single concise statement:
print(a[a > 2])     # Prints "[3 4 5 6]"

# %%
print('Numpy tensors have are typed.')

import numpy as np

x = np.array([1, 2])   # Let numpy choose the datatype
print(x.dtype)         # Prints "int64"

x = np.array([1.0, 2.0])   # Let numpy choose the datatype
print(x.dtype)             # Prints "float64"

x = np.array([1, 2], dtype=np.int64)   # Force a particular datatype
print(x.dtype)                         # Prints "int64"

# %%
print('Elementwise operations:')

import numpy as np

x = np.array([[1,2],[3,4]], dtype=np.float64)
y = np.array([[5,6],[7,8]], dtype=np.float64)

# Elementwise sum; both produce the array
# [[ 6.0  8.0]
#  [10.0 12.0]]
print(x + y)
print(np.add(x, y))

# Elementwise difference; both produce the array
# [[-4.0 -4.0]
#  [-4.0 -4.0]]
print(x - y)
print(np.subtract(x, y))

# Elementwise product; both produce the array
# [[ 5.0 12.0]
#  [21.0 32.0]]
print(x * y)
print(np.multiply(x, y))

# Elementwise division; both produce the array
# [[ 0.2         0.33333333]
#  [ 0.42857143  0.5       ]]
print(x / y)
print(np.divide(x, y))

# Elementwise square root; produces the array
# [[ 1.          1.41421356]
#  [ 1.73205081  2.        ]]
print(np.sqrt(x))

# %%
print('Inner product')
import numpy as np

x = np.array([[1,2],[3,4]])
y = np.array([[5,6],[7,8]])

v = np.array([9,10])
w = np.array([11, 12])

# Inner product of vectors; both produce 219
print(v.dot(w))
print(np.dot(v, w))

# Matrix / vector product; both produce the rank 1 array [29 67]
print(x.dot(v))
print(np.dot(x, v))
print(x @ v)

# Vector norm
from numpy.linalg import norm
print( norm(v) )

# Matrix / matrix product; both produce the rank 2 array
# [[19 22]
#  [43 50]]
print(x.dot(y))
print(np.dot(x, y))
print('Cross product')
print(np.cross(x,y))


# %%
print("Summarize matrix values")
import numpy as np

x = np.array([[1,2],[3,4]])

print(np.sum(x))  # Compute sum of all elements; prints "10"
print(np.sum(x, axis=0))  # Compute sum of each column; prints "[4 6]"
print(np.sum(x, axis=1))  # Compute sum of each row; prints "[3 7]"

print(np.mean(x,axis=0))  # Compute the mean 

# %%
print ("Transpose operation...")
import numpy as np

x = np.array([[1,2], [3,4]])
print(x)    # Prints "[[1 2]
            #          [3 4]]"
print(x.T)  # Prints "[[1 3]
            #          [2 4]]"

# Note that taking the transpose of a rank 1 array does nothing:
v = np.array([1,2,3])
print(v)    # Prints "[1 2 3]"
print(v.T)  # Prints "[1 2 3]"

# %%
print ("Matrix decompositions")
import numpy as np
A = np.array([[1,-2],[3,4]])
B = np.array([[5,6],[-7,8]])

from scipy.linalg import lu 
P, L, U = lu(A)

from numpy.linalg import qr
Q, R = qr(A, 'complete')

from numpy.linalg import eig
values, vectors = eig(A)

from scipy.linalg import svd
U, s, V = svd(A)

# %%
print ("Tiling vector into matrices.")
import numpy as np

# We will add the vector v to each row of the matrix x,
# storing the result in the matrix y
x = np.array([[1,2,3], [4,5,6], [7,8,9], [10, 11, 12]])
v = np.array([1, 0, 1])
vv = np.tile(v, (4, 1))   # Stack 4 copies of v on top of each other
print(vv)                 # Prints "[[1 0 1]
                          #          [1 0 1]
                          #          [1 0 1]
                          #          [1 0 1]]"
y = x + vv  # Add x and vv elementwise
print(y)  # Prints "[[ 2  2  4
          #          [ 5  5  7]
          #          [ 8  8 10]
          #          [11 11 13]]"


# %% WARNING !!!!
print('Numpy allows implicit Broadcasting (wraps vector to correct sizes to apply operations)')
import numpy as np

# We will add the vector v to each row of the matrix x,
# storing the result in the matrix y
x = np.array([[1,2,3], [4,5,6], [7,8,9], [10, 11, 12]])
v = np.array([1, 0, 1])
y = x + v  # Add v to each row of x using broadcasting
print(y)  # Prints "[[ 2  2  4]
          #          [ 5  5  7]
          #          [ 8  8 10]
          #          [11 11 13]]"


# %%
import numpy as np
from scipy.spatial.distance import pdist, squareform

# Create the following array where each row is a point in 2D space:
# [[0 1]
#  [1 0]
#  [2 0]]
x = np.array([[0, 1], [1, 0], [2, 0]])
print(x)

print ("Euclidean Distance Matrix ==================================")
# Compute the Euclidean distance between all rows of x.
# d[i, j] is the Euclidean distance between x[i, :] and x[j, :],
# and d is the following array:
# [[ 0.          1.41421356  2.23606798]
#  [ 1.41421356  0.          1.        ]
#  [ 2.23606798  1.          0.        ]]
d = squareform(pdist(x, 'euclidean'))
print(d)

# %%
